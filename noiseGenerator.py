'''This program creates a noise array, changes its format and
can save it's seed, save it as an image, display it in pygame.'''

import pygame
from opensimplex import OpenSimplex
import numpy as np
import random
from PIL import Image

def numberToGreyColor(num, transparence):
    '''Function that takes a number from 0 to 255
    and returns a greyscale color value
    with a given transparence'''
    return (num, num, num, transparence)


class OpenSimplexNoise():
    '''Class meant to store a noise array and all the methods related to it'''

    def __init__(self, name, width, height, frequency, octaves, seed = None):
        self.name = name
        self.width = width
        self.height = height
        self.freq = frequency
        self.seed = seed
        self.octaves = octaves

        #If it is not given, generates and stores the seed
        #Used to generate the noise array.
        if self.seed == None:
            self.seed = random.randint(1, 500)

        #Initialises the noise object using the opensimplex library using the seed
        self.originalNoiseObject = OpenSimplex(self.seed)

        #Array to store the values we will be using
        #We chose numpy  to learn how to use it and because it is
        #apparently a better choice
        self.noiseArray = np.empty([self.height, self.width])

    def generateNoiseArray(self):
        '''This method generates the noise array we will use'''
        #y and x are the coordinates of the 2d array
        for y in range(self.height):
            for x in range(self.width):
                
                #This helps with the scale
                heightWidthAverage = (self.height + self.width)/2
                
                nx = 2 * x / heightWidthAverage
                ny = 2 * y / heightWidthAverage

                #This line generates the value of each number of the noiseArray list.
                #Each value of the list is the sum of the value defined by x and y on the different octaves (=different zooms in the noise)
                #specified in the octaves argument. That corresponds to self.originalNoiseObject.noise2d(i * self.freq*nx, i * self.freq*ny.
                #i is the scale/frequency of each octave.
                #(It is different from freq, the overall frenquency of the resulting list.)
                #the value defined by x and y on each octave is multiplied by a number, j, that represents how important is that octave.
                #It may be 1 for the main octave, 0,5 for the second one, 0,25 for the third one etc.
                #The lower the j number is, more transaparent this octave will be, it will have less of an effect overall.
                #The format for the octaves argument is the following dict
                #octaves = {freqOfOctaveOne: importanceOfOctaveOne, freqOfOctaveTwo: importanceOfOctaveTwo ...}
                #or octaves = {i: j, i2: j2, ...}
                #I used list comprehension so this works with any given number of octaves.
                #In a terrain generation context this is meant to make more complex and natural lookin noise
                #Though in general we can use it to make different looking noise images
                #I'm quite proud of this line

                self.noiseArray[y][x] = sum(j * self.originalNoiseObject.noise2d(i * self.freq * nx, i * self.freq * ny) for i, j in self.octaves.items())

    def mapArbValueToColorValue(self):
        '''
        The values generated by generateNoiseArray are values from -1.50 to 1.50 aprox
        We need the to go from 0 to 255 to use the, as colors
        This method does that
        We may try to use the map function instead later
        '''
        for j in range(len(self.noiseArray)):
            for i in range(len(self.noiseArray[j])):
                num = round(255 / sum(j for i, j in self.octaves.items())) * self.noiseArray[j][i] + 255/2
                if num > 255:
                    num = 255
                if num < 0:
                    num = 0
                self.noiseArray[j][i] = num
                

    def drawInPygame(self, display, x, y, scale):
        '''This method displays the noise array as rect objects on a pygame screen'''
        
        #It may be better for performance to use an image instead of an array to do that
        for j in range(len(self.noiseArray[0])):
            for i in range(len(self.noiseArray[0][j])):
                pygame.draw.rect(display,(self.noiseArray[0][j][i], self.noiseArray[0][j][i], \
                self.noiseArray[0][j][i]),(x + i * scale , y + j * scale, scale, scale))

    def saveAsPNG(self, path = ""):
        '''This method generates a PNG image using the noiseArray and saves it'''
        img = Image.new('RGBA', (self.width, self.height))

        for j in range(len(self.noiseArray)):
            for i in range(len(self.noiseArray[j])):
                img.putpixel( (i,j), numberToGreyColor( int(self.noiseArray[j][i]), 255 ) )

        img.save(path + str(self.name) + '_noise.png')

    def saveSeedAsTxtFile(self, path = ""):
        '''This method saves the seed in a txt file to use it later'''
        seedFile = open(path + str(self.name) + ".txt" , "a")
        seedFile.write(2 * "\n" + str(self.seed))
        seedFile.close()

#The format of this dict is explained in the generateNoiseArray mathod definition.
octaves = {1 : 1,
           2 : 0.5,
           4 : 0.25,
           8 : 0.125}

#Test, only if this file is run and not imported
if __name__ == "__main__":
    noiseTest = OpenSimplexNoise("noiseTest", 300, 300, 2, octaves, 0)
    noiseTest.generateNoiseArray()
    noiseTest.mapArbValueToColorValue()
    noiseTest.saveAsPNG('gameImages\ ')
    noiseTest.saveSeedAsTxtFile('seeds\ ')


